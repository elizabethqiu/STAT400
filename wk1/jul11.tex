\section{Monday, July 11, 2019}
This class is STAT400: Applied Probability and Statistics I. Topics covered: random variables, standard distributions, moments, law of large numbers and central limit theorem, sampling methods, estimation of parameters, testing of hypotheses.

\subsection{Logistics}
\begin{itemize}
	\item Textbook: Devore (2018), Probability and Statistics for Engineering and the Sciences ($9th\%$ ed). Cengage Learning.
    \item All lectures are recorded and posted on Panopto.
    \item No collaboration on projects.
    \item Frequent homework assignments and possibly pop quizzes. Assignments on ELMS.
    \item Assignments on ELMS. 
    \item The grade breakdown is $10\%$ for Homeworks, $10\%$ for Quizzes, $25\%$ for 2 Midterms $1$, and $40\%$ for the Final Exam. 
\end{itemize} 

\subsection{Probability, Statistics and Data}
In STAT400, we will visualizing and summarize data, and also use mathematical methods for data analysis.
\begin{enumerate}
	\item \vocab{Statistics} is the science of recognizing, collecting, analyzing, interpreting data.
    \item \vocab{Probability} is the mathematical theory of randomness and most of this course will be devoted to modeling random phenomena. 
	\item \vocab{Randomness} is a type of abstraction in which various data objects are known to the user, but how they are represented or implemented is not known to the user. An example of data abstraction is shown by representing a list of people. While the user would know that they have a list of people, they wouldn't know how the list is being represented (for example, we could use an array, an ArrayList, or any other data structure).
\end{enumerate}

## We went over the "Newcomb's 1882 Measurements" example, where measurements of the passage time of light were recorded by NewComb in 1882. Given values divided by 1000 plus 24 give the time in microseconds for light to traverse a known distance. We had a dataset with a summary of a minimum, 1st quartile value, median, mean, 3rd quartile value, maximum value, and standard deviation.


Once we have the central value of the data: "how close/far do we expect the values to be?"
Later: standard deviation: value that tells you how close/far away from typical observation we see data / absval of typical distance from mean
Histogram: good for visualizing data, shape of graph tells you typical distributions
Outliers: outside of bulk of data

Interpreting histograms:
- Values that are clearly separated from others = outliers
- Roughly follow "bell curve". Low ends of scales, maximum near mean or median. Bell shapes are not recognized without the graph
- Dropping outliers: only slightly change the mean and median, but may greatly affect standard deviation (outliers affect spread greatly)

Comparing samples graphically: histograms give good viz of shape/distributions
\vocab{Boxplot} = we take the min observation, max observation, lower and upper lines are 1st and 3rd quartiles, heavy line in middle is median. Whiskers (horizontal lines) measure spread: interquartile range.
Boxplot of a single sample is not really that useful, especially where calculations can be made instantly with a couple lines of code. But it's just as easy to create a histogram.
Don't worry too much about Count Data.
Most data we will encounter in this course is Measurement Data.

## Cereals
Histograms are not a reliable indicator when you have small samples of data, like we have in this example.

Recommended: Learn R. You can also use R to analyze data. It's free!



\subsection{The Java Programming Language}
Different programming languages provide varying levels of support for object-oriented programming. In particular, Java and C++ allow us to easily perform object-oriented programming. How does Java does this?
\begin{itemize}
    \item Java provides us with \vocab{interfaces}, which allows us to specify a set of methods that another class must implement. This allows us to easily express an abstract data type since we can specify the operations and data that an entity must have. Interfaces follow an ``is-a" relationship, meaning that a class that implements an interface is what the interface specifies. As an example, consider an animal interface. If an elephant implements the animal interface, we can perform tasks that are meant for animals with elephants (such as passing an elephant into a function that accepts animals). 
    \item Java provides us with \vocab{classes}, which can be used as blueprints for other classes. Classes can extend other classes, which makes them \vocab{subclasses}. These subclasses inherit functions from the original class, and this also defines an ``is-a" relationship. 
\end{itemize}

Here are some key points that we should remember about interfaces:
\begin{itemize}
    \item An interface cannot be instantiated. So, if we have an interface called \verb!animal!, typing \verb!Animal a = new Animal()! \textbf{would not compile}.
    \item An interface can contain many public members, including static final constants, abstract methods (which have no body), default methods (with a body), static methods, and static nested types.
\end{itemize}

Let's look at an example of an interface:

\begin{lstlisting}
    import java.util.*;

    public interface Animal {
        
        public void feed(String food);
        public int getAge();
        public boolean manBestFriend();
        
        default void grow() {
            System.out.println("I grow");
        }
    }
\end{lstlisting}

Here, we've created an interface named \verb!Animal!, which other classes can implement. Any class that implements this class will need to also implement the functions \verb!feed!, \verb!getAge()! and \verb!manBestFriend()! with the same return values and parameters specified. The \verb!grow()! function will be associated with any class that implements this interface.

Now let's look at another class that implements the \verb!Animal! interface:

\begin{lstlisting}
package animalExample;

public class Dog implements Animal {
	private String name;
	private int age;

	public Dog(String name, int age) {
		this.name = name;
		this.age = age;

	}

	public void feed(String food) {
		System.out.println("Feeding " + name + " with " + food);
	}

	public int getAge() {
		return age;
	}

	public boolean manBestFriend() {
		return true;
	}

	public void bark() {
		System.out.println(name + " is barking");
	}
}
\end{lstlisting}

Here are the key things that we should note:
\begin{itemize}
    \item The \verb!Dog! class implements the \verb!Animal! class. Thus, it is \textbf{required} to implement all of the methods specified by \verb!Animal! (if we were to comment out even one function, the code wouldn't compile).
    \item The \verb!Dog! class is allowed to add its own methods, like \verb!bark()!. Likewise, the \verb!Dog! class is allowed to create its own variables, like \verb!name! and \verb!age!.
\end{itemize}

Here's another class that implements the \verb!Animal! interface:

\begin{lstlisting}
package animalExample;

public class Piranha implements Animal {
	private int age;

	public Piranha(int age) {
		this.age = age;
	}

	public void feed(String food) {
		System.out.println("Piranha is eating " + food);
	}

	public int getAge() {
		return age;
	}

	public boolean manBestFriend() {
		return false;
	}

	public void grow() {
		System.out.println("I grow like a fish");
	}
}
\end{lstlisting}

Here are some more things that we should take careful note of: \begin{itemize}
    \item More than one class can implement an interface. In this example, both \verb!Dog! and \verb!Piranha! implement \verb!Animal!.
    \item We can rewrite methods that are provided to us. More specifically, \verb!Piranha! implements \verb!Animal!, but it rewrites the \verb!grow()! function that was originally provided to it.
\end{itemize}

Recall that interfaces define an ``is-a" relationship. Since \verb!Piranha! and \verb!Dog! implement \verb!Animal!, we can now treat them as an \verb!Animal!. A good way to verify the ``is-a" relationship is the \verb!instanceof! keyword. In Java, \verb!instanceof! allows us to check whether one object is an instance of a specified type (class, subclass, or interface).

To demonstrate, suppose we declare a piranha variable \verb!p!. We could write a conditional such as \verb!if (p instanceof Animal) { /* Code to be executed */}!, in order to make sure that \verb!p! is an instance of \verb!Animal!. Why would we ever need to do this? This is particularly useful when we're casting. If we attempt to cast an object to a subclass of which it is not an instance of, Java throws a \vocab{ClassCastException}. We can prevent this exception by putting the relevant code in a conditional checking the instance of what we're casting. 